{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"stacrs","text":"<p>A Python package for STAC using Rust under the hood.</p>"},{"location":"#why","title":"Why?","text":"<p>Q: We already have PySTAC, so why stacrs?</p> <p>A: stacrs can</p> <ul> <li>Read, write, and search stac-geoparquet</li> <li>Go to and from arrow tables, allowing easy interoperability with (e.g.) GeoPandas</li> <li><code>async</code></li> </ul> <p>If you don't need those things, stacrs probably isn't for you \u2014 use pystac and its friend, pystac-client.</p>"},{"location":"#usage","title":"Usage","text":"<p>Install via pip:</p> <pre><code># basic\npython -m pip install stacrs\n\n# support arrow tables\npython -m pip install 'stacrs[arrow]'\n</code></pre> <p>Or via conda:</p> <pre><code>conda install conda-forge::stacrs\n</code></pre> <p>Then:</p> <pre><code>import stacrs\n\n# Search a STAC API\nitems = await stacrs.search(\n    \"https://landsatlook.usgs.gov/stac-server\",\n    collections=\"landsat-c2l2-sr\",\n    intersects={\"type\": \"Point\", \"coordinates\": [-105.119, 40.173]},\n    sortby=\"-properties.datetime\",\n    max_items=100,\n)\n\n# If you installed with `pystac[arrow]`:\nfrom geopandas import GeoDataFrame\ntable = await stacrs.search_to_arrow(...)\ndata_frame = GeoDataFrame.from_arrow(table)\nitems = stacrs.from_arrow(data_frame.to_arrow())\n\n# Write items to a stac-geoparquet file\nawait stacrs.write(\"items.parquet\", items)\n\n# Read items from a stac-geoparquet file as an item collection\nitem_collection = await stacrs.read(\"items.parquet\")\n\n# You can search geoparquet files using DuckDB\n# If you want to search a file on s3, make sure to configure your AWS environment first\nitem_collection = await stacrs.search(\"s3://bucket/items.parquet\", ...)\n\n# Use `search_to` for better performance if you know you'll be writing the items\n# to a file\nawait stacrs.search_to(\n    \"items.parquet\",\n    \"https://landsatlook.usgs.gov/stac-server\",\n    collections=\"landsat-c2l2-sr\",\n    intersects={\"type\": \"Point\", \"coordinates\": [-105.119, 40.173]},\n    sortby=\"-properties.datetime\",\n    max_items=100,\n)\n</code></pre> <p>See the documentation for details. In particular, our example notebook demonstrates some of the more interesting features.</p>"},{"location":"#cli","title":"CLI","text":"<p>stacrs comes with a CLI:</p> <pre><code>$ stacrs -h\nstacrs: A command-line interface for the SpatioTemporal Asset Catalog (STAC)\n\nUsage: stacrs [OPTIONS] &lt;COMMAND&gt;\n\nCommands:\n  translate  Translates STAC from one format to another\n  search     Searches a STAC API or stac-geoparquet file\n  serve      Serves a STAC API\n  validate   Validates a STAC value\n  help       Print this message or the help of the given subcommand(s)\n\nOptions:\n  -i, --input-format &lt;INPUT_FORMAT&gt;\n          The input format.\n      --opt &lt;OPTIONS&gt;\n          Options for getting and putting files from object storage.\n  -o, --output-format &lt;OUTPUT_FORMAT&gt;\n          The output format.\n  -c, --compact-json &lt;COMPACT_JSON&gt;\n          Whether to print compact JSON output [possible values: true, false]\n      --parquet-compression &lt;PARQUET_COMPRESSION&gt;\n          The parquet compression to use when writing stac-geoparquet.\n  -h, --help\n          Print help (see more with '--help')\n</code></pre> <p>[!NOTE] Before stacrs v0.5.4, the CLI was its own PyPI package named stacrs-cli, which is no longer needed.</p>"},{"location":"#stac-geoparquet","title":"stac-geoparquet","text":"<p>stacrs replicates much of the behavior in the stac-geoparquet library, and even uses some of the same Rust dependencies. We believe there are a couple of issues with stac-geoparquet that make stacrs a worthy replacement:</p> <ul> <li>The stac-geoparquet repo includes Python dependencies</li> <li>It doesn't have a nice one-shot API for reading and writing</li> <li>It includes some leftover code and logic from its genesis as a tool for the Microsoft Planetary Computer</li> </ul> <p>We test to ensure compatibility between the two libraries, and we intend to consolidate to a single \"stac-geoparquet\" library at some point in the future.</p>"},{"location":"#development","title":"Development","text":"<p>Get Rust, uv, and (optionally) libduckdb. Then:</p> <pre><code>git clone git@github.com:stac-utils/stacrs.git\ncd stacrs\nscripts/test\n</code></pre> <p>See CONTRIBUTING.md for more information about contributing to this project.</p>"},{"location":"#duckdb","title":"DuckDB","text":"<p>By default, this package expects libduckdb to be present on your system. If you get this sort of error when building:</p> <pre><code>  = note: ld: library 'duckdb' not found\n</code></pre> <p>Set your <code>DUCKDB_LIB_DIR</code> to point to your libduckdb. If you're using homebrew, that might look like this:</p> <pre><code>export DUCKDB_LIB_DIR=/opt/homebrew/lib\n</code></pre> <p>Alternatively, you can use the <code>duckdb-bundled</code> feature to build DuckDB bindings into the Rust library:</p> <pre><code>maturin dev --uv -F duckdb-bundled &amp;&amp; pytest\n</code></pre> <p>[!WARNING] Building DuckDB bundled takes a long while.</p>"},{"location":"#license","title":"License","text":"<p>stacrs is dual-licensed under both the MIT license and the Apache license (Version 2.0). See LICENSE-APACHE and LICENSE-MIT for details.</p>"},{"location":"CONTRIBUTING/","title":"Contributing","text":"<p>First off, thanks for contributing! We appreciates you.</p>"},{"location":"CONTRIBUTING/#testing","title":"Testing","text":"<p>We aim for comprehensive unit testing of this library. Please provide tests for any new features, or to demonstrate bugs. Draft pull requests with a failing test to demonstrate a bug are much appreciated.</p>"},{"location":"CONTRIBUTING/#submitting-changes","title":"Submitting changes","text":"<p>Please open a pull request with your changes -- make sure to include unit tests. Please follow standard git commit formatting (subject line 50 characters max, wrap the body at 72 characters).</p> <p>We use conventional commits. Your commits do not have to but if you'd like to format them this way, we would be grateful.</p> <p>If you can, use <code>git rebase -i</code> to create a clean, well-formatted history before opening your pull request. If you need to make changes after opening your pull request (e.g. to fix CI breakages) we will be grateful if you squash those fixes into their relevant commits.</p> <p>Thanks so much!</p> <p>-Pete Gadomski</p>"},{"location":"example/","title":"Example notebook","text":"In\u00a0[6]: Copied! <pre>import stacrs\n\nitems = await stacrs.search(\n    \"https://stac.eoapi.dev\",\n    collections=\"openaerialmap\",\n    bbox=[-125, 25, -67, 49],  # CONUS\n    sortby=\"-properties.datetime\",\n    max_items=1000,\n)\nawait stacrs.write(\n    \"items.parquet\", items, format=\"parquet[snappy]\"\n)  # compressed stac-geoparquet\n</pre> import stacrs  items = await stacrs.search(     \"https://stac.eoapi.dev\",     collections=\"openaerialmap\",     bbox=[-125, 25, -67, 49],  # CONUS     sortby=\"-properties.datetime\",     max_items=1000, ) await stacrs.write(     \"items.parquet\", items, format=\"parquet[snappy]\" )  # compressed stac-geoparquet In\u00a0[7]: Copied! <pre>import contextily\nimport stacrs\nfrom geopandas import GeoDataFrame\n\nurl = \"https://github.com/gadomski/2024-09-FOSS4G-NA-stac-rs/raw/refs/heads/main/benches/1000-sentinel-2-items-stac-rs.parquet\"\nitems = await stacrs.search(\n    url, intersects={\"type\": \"Point\", \"coordinates\": [-105.1019, 40.1672]}\n)\nprint(f\"Found {len(items)} items\")\ndata_frame = GeoDataFrame.from_features(items, crs=\"EPSG:4326\")\naxis = data_frame.plot(facecolor=\"none\")\ncontextily.add_basemap(axis, crs=data_frame.crs.to_string())\n</pre> import contextily import stacrs from geopandas import GeoDataFrame  url = \"https://github.com/gadomski/2024-09-FOSS4G-NA-stac-rs/raw/refs/heads/main/benches/1000-sentinel-2-items-stac-rs.parquet\" items = await stacrs.search(     url, intersects={\"type\": \"Point\", \"coordinates\": [-105.1019, 40.1672]} ) print(f\"Found {len(items)} items\") data_frame = GeoDataFrame.from_features(items, crs=\"EPSG:4326\") axis = data_frame.plot(facecolor=\"none\") contextily.add_basemap(axis, crs=data_frame.crs.to_string()) <pre>Found 20 items\n</pre> In\u00a0[8]: Copied! <pre>from stacrs import DuckdbClient\n\nclient = DuckdbClient()\nitems = client.search_to_arrow(\n    \"items.parquet\", datetime=\"2020-01-01T00:00:00Z/..\"\n)  # you can search a parquet file with DuckDB\ndata_frame = GeoDataFrame.from_arrow(items)\ndata_frame\n</pre> from stacrs import DuckdbClient  client = DuckdbClient() items = client.search_to_arrow(     \"items.parquet\", datetime=\"2020-01-01T00:00:00Z/..\" )  # you can search a parquet file with DuckDB data_frame = GeoDataFrame.from_arrow(items) data_frame Out[8]: stac_version stac_extensions id file:size provider links assets collection datetime start_datetime end_datetime title platform bbox geometry filename 0 1.1.0 [https://stac-extensions.github.io/file/v2.1.0... 66de01d9cd0baa0001b61fd3 5647695 Efthimios F. [{'href': 'https://stac.eoapi.dev/collections/... {'image': {'href': 'https://oin-hotosm.s3.us-e... openaerialmap NaT 2024-09-07 22:00:00-06:00 2024-09-08 13:33:51.317000-06:00 Honesdale Pa uav {'xmin': -75.257933, 'ymin': 41.566194, 'xmax'... MULTIPOLYGON (((-75.25793 41.56724, -75.25793 ... items.parquet 1 1.1.0 [https://stac-extensions.github.io/file/v2.1.0... 66d4981611a1ae0001f7b089 3337391 South Holston Drone Operations [{'href': 'https://stac.eoapi.dev/collections/... {'image': {'href': 'https://oin-hotosm.s3.us-e... openaerialmap NaT 2024-08-31 22:00:00-06:00 2024-09-01 10:26:39.555000-06:00 K Jones 2 satellite {'xmin': -82.213313, 'ymin': 36.619578, 'xmax'... MULTIPOLYGON (((-82.21331 36.62206, -82.21327 ... items.parquet 2 1.1.0 [https://stac-extensions.github.io/file/v2.1.0... 66d497a011a1ae0001f7b088 9975450 South Holston Drone Operations [{'href': 'https://stac.eoapi.dev/collections/... {'image': {'href': 'https://oin-hotosm.s3.us-e... openaerialmap NaT 2024-08-29 22:00:00-06:00 2024-08-29 23:00:00-06:00 K Jones uav {'xmin': -82.212749, 'ymin': 36.620306, 'xmax'... MULTIPOLYGON (((-82.21275 36.62301, -82.21271 ... items.parquet 3 1.1.0 [https://stac-extensions.github.io/file/v2.1.0... 66db50c5cd0baa0001b61f88 23125850 WebODM [{'href': 'https://stac.eoapi.dev/collections/... {'image': {'href': 'https://oin-hotosm.s3.us-e... openaerialmap NaT 2024-08-22 13:00:00-06:00 2024-08-22 14:00:00-06:00 County Park uav {'xmin': -88.535721, 'ymin': 44.0783, 'xmax': ... MULTIPOLYGON (((-88.53572 44.08013, -88.53567 ... items.parquet 4 1.1.0 [https://stac-extensions.github.io/file/v2.1.0... 66cf527611a1ae0001f7afbf 208119745 FOUR POINTS [{'href': 'https://stac.eoapi.dev/collections/... {'image': {'href': 'https://oin-hotosm.s3.us-e... openaerialmap NaT 2024-08-15 05:15:47-06:00 2024-08-15 06:15:47-06:00 Fifth Road East - 8/15/2024 uav {'xmin': -79.730944, 'ymin': 43.176711, 'xmax'... MULTIPOLYGON (((-79.73067 43.19008, -79.73094 ... items.parquet ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... ... 738 1.1.0 [https://stac-extensions.github.io/file/v2.1.0... 5e227dbe50259f000541fc42 9874294 WebODM [{'href': 'https://stac.eoapi.dev/collections/... {'image': {'href': 'https://oin-hotosm.s3.amaz... openaerialmap NaT 2020-01-17 05:31:34-07:00 2020-01-17 06:31:34-07:00 Task of 2020-01-18T02:04:04.280Z uav {'xmin': -119.001888, 'ymin': 34.211746, 'xmax... MULTIPOLYGON (((-119.00189 34.21296, -119.0018... items.parquet 739 1.1.0 [https://stac-extensions.github.io/file/v2.1.0... 5e223b4e50259f000541fc3c 21102668 tirogue [{'href': 'https://stac.eoapi.dev/collections/... {'image': {'href': 'https://oin-hotosm.s3.amaz... openaerialmap NaT 2020-01-17 00:00:00-07:00 2020-01-17 15:47:10.155000-07:00 akiwik,i satellite {'xmin': -110.956421, 'ymin': 29.03546, 'xmax'... MULTIPOLYGON (((-110.95642 29.04026, -110.9564... items.parquet 740 1.1.0 [https://stac-extensions.github.io/file/v2.1.0... 5e22ba7650259f000541fc45 67917267 WebODM [{'href': 'https://stac.eoapi.dev/collections/... {'image': {'href': 'https://oin-hotosm.s3.amaz... openaerialmap NaT 2020-01-15 06:49:16-07:00 2020-01-15 11:49:16-07:00 Shepard Rollins Trail East 2020-01-15 uav {'xmin': -92.312534, 'ymin': 38.938449, 'xmax'... MULTIPOLYGON (((-92.31249 38.94295, -92.31253 ... items.parquet 741 1.1.0 [https://stac-extensions.github.io/file/v2.1.0... 5e22bc0f50259f000541fc48 10911074 WebODM [{'href': 'https://stac.eoapi.dev/collections/... {'image': {'href': 'https://oin-hotosm.s3.amaz... openaerialmap NaT 2020-01-15 01:31:05-07:00 2020-01-15 02:31:05-07:00 Shepard Rollins Trail West 2020-01-15 uav {'xmin': -92.315732, 'ymin': 38.939029, 'xmax'... MULTIPOLYGON (((-92.31571 38.94125, -92.31573 ... items.parquet 742 1.1.0 [https://stac-extensions.github.io/file/v2.1.0... 5e17fbb676e4f20005c1b85f 805518 WebODM [{'href': 'https://stac.eoapi.dev/collections/... {'image': {'href': 'https://oin-hotosm.s3.amaz... openaerialmap NaT 2020-01-09 09:34:13-07:00 2020-01-09 10:34:13-07:00 Task of 2020-01-10T02:19:38.304Z uav {'xmin': -119.228306, 'ymin': 34.247821, 'xmax... MULTIPOLYGON (((-119.22831 34.24823, -119.2283... items.parquet <p>743 rows \u00d7 16 columns</p> <p>Because of the way GeoPandas handles underlying arrays and dictionaries, you can't go directly back to a JSON dictionary via <code>to_json</code>. However, you can go back through stac-geoparquet via <code>to_arrow</code>.</p> In\u00a0[11]: Copied! <pre>from pystac import ItemCollection\n\ntable = data_frame.to_arrow()\nitem_collection_dict = stacrs.from_arrow(table)\n_ = ItemCollection.from_dict(item_collection_dict)\n</pre> from pystac import ItemCollection  table = data_frame.to_arrow() item_collection_dict = stacrs.from_arrow(table) _ = ItemCollection.from_dict(item_collection_dict) In\u00a0[10]: Copied! <pre>await stacrs.search_to(\n    \"items.parquet\",\n    \"https://stac.eoapi.dev\",\n    collections=\"openaerialmap\",\n    bbox=[-125, 25, -67, 49],  # CONUS\n    sortby=\"-properties.datetime\",\n    max_items=1000,\n    format=\"parquet[snappy]\",\n)\n</pre> await stacrs.search_to(     \"items.parquet\",     \"https://stac.eoapi.dev\",     collections=\"openaerialmap\",     bbox=[-125, 25, -67, 49],  # CONUS     sortby=\"-properties.datetime\",     max_items=1000,     format=\"parquet[snappy]\", ) Out[10]: <pre>1000</pre>"},{"location":"example/#example-notebook","title":"Example notebook\u00b6","text":"<p>This notebook demonstrates some of the more interesting features of stacrs.</p>"},{"location":"example/#stac-geoparquet","title":"stac-geoparquet\u00b6","text":"<p>The stac-geoparquet specification describes how to store STAC items in a geoparquet. Use stacrs to read and write stac-geoparquet.</p>"},{"location":"example/#search","title":"Search\u00b6","text":"<p>In addition to using <code>search</code> on STAC APIs, you can use DuckDB to search stac-geoparquet.</p>"},{"location":"example/#to-arrow","title":"To arrow\u00b6","text":"<p>If you installed stacrs with the <code>arrow</code> extra (<code>python -m pip install 'stacrs[arrow]'</code>) you can search stac-geoparquet files into an arrow table, which can be loaded directly into (e.g.) GeoPandas. This will be significantly more efficient than loading Python dictionaries into a data frame.</p>"},{"location":"example/#search-to","title":"Search to\u00b6","text":"<p>If you want to save the results of a STAC API search directly to a file, use <code>search_to</code>. This will generally be more performant than using <code>search</code> then <code>write</code>.</p>"},{"location":"api/","title":"Python API","text":"<p>API documentation for the stacrs Python package.</p>"},{"location":"api/#format","title":"Format","text":"<p>Several functions, including stacrs.write, take a <code>format</code> argument. Valid values are:</p> <ul> <li><code>json</code> or <code>geojson</code>: compact (no whitespace) JSON</li> <li><code>json-pretty</code> or <code>geojson-pretty</code>: indented JSON</li> <li><code>ndjson</code>: newline-delimited JSON (also known as <code>geojson-seq</code>)</li> <li><code>parquet</code> or <code>geoparquet</code>: uncompressed geoparquet</li> <li><code>parquet[{compression}]</code> or <code>geoparquet[{compression}]</code>: compressed parquet, where valid values for <code>compression</code> are the lowercase string versions of the values enumerated in stac::geoparquet::Compression.</li> </ul> <p>Tip</p> <p>If you're not sure which geoparquet compression to use, we suggest <code>parquet[snappy]</code></p> <p>Note</p> <p>The distinction between pretty and compact JSON, or compressed and uncompressed geoparquet, is only relevant on write. On read, the formats are treated the same.</p> <p>Under the hood, the <code>format</code> argument is parsed into a Format enum.</p>"},{"location":"api/arrow/","title":"Arrow","text":"<p>These functions require the <code>arrow</code> extra, e.g.:</p> <pre><code>python -m pip install 'stacrs[arrow]'\n</code></pre>"},{"location":"api/arrow/#stacrs.to_arrow","title":"stacrs.to_arrow","text":"<pre><code>to_arrow(items: list[dict[str, Any]] | dict[str, Any]) -&gt; Table\n</code></pre> <p>Converts items to an arro3.core.Table.</p> <p>Requires stacrs to be installed with the <code>arrow</code> extra.</p> <p>Parameters:</p> <ul> <li> <code>items</code>               (<code>list[dict[str, Any]] | dict[str, Any]</code>)           \u2013            <p>Either a list of items or a item collection</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table</code>           \u2013            <p>The table</p> </li> </ul>"},{"location":"api/arrow/#stacrs.from_arrow","title":"stacrs.from_arrow","text":"<pre><code>from_arrow(table: Table) -&gt; dict[str, Any]\n</code></pre> <p>Converts an arro3.core.Table to a STAC item collection.</p> <p>Requires stacrs to be installed with the <code>arrow</code> extra.</p> <p>Parameters:</p> <ul> <li> <code>table</code>               (<code>Table</code>)           \u2013            <p>The table</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>The STAC item collection</p> </li> </ul>"},{"location":"api/duckdb/","title":"DuckDB","text":""},{"location":"api/duckdb/#stacrs.DuckdbClient","title":"stacrs.DuckdbClient","text":"<p>A client for querying stac-geoparquet with DuckDB.</p>"},{"location":"api/duckdb/#stacrs.DuckdbClient.__init__","title":"__init__","text":"<pre><code>__init__(\n    use_s3_credential_chain: bool = True, use_hive_partitioning: bool = False\n) -&gt; None\n</code></pre> <p>Creates a new duckdb client.</p> <p>Parameters:</p> <ul> <li> <code>use_s3_credential_chain</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If true, configures DuckDB to correctly handle s3:// urls.</p> </li> <li> <code>use_hive_partitioning</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, enables queries on hive partitioned geoparquet files.</p> </li> </ul>"},{"location":"api/duckdb/#stacrs.DuckdbClient.get_collections","title":"get_collections","text":"<pre><code>get_collections(href: str) -&gt; list[dict[str, Any]]\n</code></pre> <p>Returns all collections in this stac-geoparquet file.</p> <p>These collections will be auto-generated from the STAC items, one collection per id in the <code>collections</code> column.</p> <p>Eventually, these collections might be stored in the stac-geoparquet metadata and retrieved from there, but that's not the case yet.</p> <p>Parameters:</p> <ul> <li> <code>href</code>               (<code>str</code>)           \u2013            <p>The stac-geoparquet file to build the collections from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>A list of STAC Collections</p> </li> </ul>"},{"location":"api/duckdb/#stacrs.DuckdbClient.search","title":"search","text":"<pre><code>search(\n    href: str,\n    *,\n    ids: Optional[str | list[str]] = None,\n    collections: Optional[str | list[str]] = None,\n    intersects: Optional[str | dict[str, Any]] = None,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None,\n    bbox: Optional[list[float]] = None,\n    datetime: Optional[str] = None,\n    include: Optional[str | list[str]] = None,\n    exclude: Optional[str | list[str]] = None,\n    sortby: Optional[str | list[str]] = None,\n    filter: Optional[str | dict[str, Any]] = None,\n    query: Optional[dict[str, Any]] = None,\n    **kwargs: str,\n) -&gt; dict[str, Any]\n</code></pre> <p>Search a stac-geoparquet file with duckdb, returning an item collection.</p> <p>Parameters:</p> <ul> <li> <code>href</code>               (<code>str</code>)           \u2013            <p>The stac-geoparquet file.</p> </li> <li> <code>ids</code>               (<code>Optional[str | list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Array of Item ids to return.</p> </li> <li> <code>collections</code>               (<code>Optional[str | list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Array of one or more Collection IDs that each matching Item must be in.</p> </li> <li> <code>intersects</code>               (<code>Optional[str | dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>Searches items by performing intersection between their geometry and provided GeoJSON geometry.</p> </li> <li> <code>limit</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>The number of items to return.</p> </li> <li> <code>offset</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>The number of items to skip before returning.</p> </li> <li> <code>bbox</code>               (<code>Optional[list[float]]</code>, default:                   <code>None</code> )           \u2013            <p>Requested bounding box.</p> </li> <li> <code>datetime</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Single date+time, or a range (<code>/</code> separator), formatted to RFC 3339, section 5.6.  Use double dots .. for open date ranges.</p> </li> <li> <code>include</code>               (<code>Optional[str | list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>fields to include in the response (see the extension docs) for more on the semantics).</p> </li> <li> <code>exclude</code>               (<code>Optional[str | list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>fields to exclude from the response (see the extension docs) for more on the semantics).</p> </li> <li> <code>sortby</code>               (<code>Optional[str | list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Fields by which to sort results (use <code>-field</code> to sort descending).</p> </li> <li> <code>filter</code>               (<code>Optional[str | dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>CQL2 filter expression. Strings will be interpreted as cql2-text, dictionaries as cql2-json.</p> </li> <li> <code>query</code>               (<code>Optional[dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>Additional filtering based on properties.  It is recommended to use filter instead, if possible.</p> </li> <li> <code>kwargs</code>               (<code>str</code>, default:                   <code>{}</code> )           \u2013            <p>Additional parameters to pass in to the search.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>A feature collection of STAC items.</p> </li> </ul>"},{"location":"api/duckdb/#stacrs.DuckdbClient.search_to_arrow","title":"search_to_arrow","text":"<pre><code>search_to_arrow(\n    href: str,\n    *,\n    ids: Optional[str | list[str]] = None,\n    collections: Optional[str | list[str]] = None,\n    intersects: Optional[str | dict[str, Any]] = None,\n    limit: Optional[int] = None,\n    offset: Optional[int] = None,\n    bbox: Optional[list[float]] = None,\n    datetime: Optional[str] = None,\n    include: Optional[str | list[str]] = None,\n    exclude: Optional[str | list[str]] = None,\n    sortby: Optional[str | list[str]] = None,\n    filter: Optional[str | dict[str, Any]] = None,\n    query: Optional[dict[str, Any]] = None,\n    **kwargs: str,\n) -&gt; Table | None\n</code></pre> <p>Search a stac-geoparquet file with duckdb, returning an arrow table suitable for loading into (e.g.) GeoPandas.</p> <p>stacrs must be installed with the <code>arrow</code> extra, e.g. `python -m pip *install 'stacrs[arrow]'.</p> <p>Because DuckDB has arrow as a core output format, this can be more performant than going through a JSON dictionary.</p> <p>Parameters:</p> <ul> <li> <code>href</code>               (<code>str</code>)           \u2013            <p>The stac-geoparquet file.</p> </li> <li> <code>ids</code>               (<code>Optional[str | list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Array of Item ids to return.</p> </li> <li> <code>collections</code>               (<code>Optional[str | list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Array of one or more Collection IDs that each matching Item must be in.</p> </li> <li> <code>intersects</code>               (<code>Optional[str | dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>Searches items by performing intersection between their geometry and provided GeoJSON geometry.</p> </li> <li> <code>limit</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>The number of items to return.</p> </li> <li> <code>offset</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>The number of items to skip before returning.</p> </li> <li> <code>bbox</code>               (<code>Optional[list[float]]</code>, default:                   <code>None</code> )           \u2013            <p>Requested bounding box.</p> </li> <li> <code>datetime</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Single date+time, or a range (<code>/</code> separator), formatted to RFC 3339, section 5.6.  Use double dots .. for open date ranges.</p> </li> <li> <code>include</code>               (<code>Optional[str | list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>fields to include in the response (see the extension docs) for more on the semantics).</p> </li> <li> <code>exclude</code>               (<code>Optional[str | list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>fields to exclude from the response (see the extension docs) for more on the semantics).</p> </li> <li> <code>sortby</code>               (<code>Optional[str | list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Fields by which to sort results (use <code>-field</code> to sort descending).</p> </li> <li> <code>filter</code>               (<code>Optional[str | dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>CQL2 filter expression. Strings will be interpreted as cql2-text, dictionaries as cql2-json.</p> </li> <li> <code>query</code>               (<code>Optional[dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>Additional filtering based on properties.  It is recommended to use filter instead, if possible.</p> </li> <li> <code>kwargs</code>               (<code>str</code>, default:                   <code>{}</code> )           \u2013            <p>Additional parameters to pass in to the search.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Table | None</code>           \u2013            <p>An arrow table, or none if no records were returned.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; table = client.search_to_arrow(\"data/100-sentinel-2-items.parquet\")\n&gt;&gt;&gt; data_frame = GeoDataFrame.from_arrow(table)\n</code></pre>"},{"location":"api/migrate/","title":"Migration","text":""},{"location":"api/migrate/#stacrs.migrate","title":"stacrs.migrate","text":"<pre><code>migrate(value: dict[str, Any], version: Optional[str] = None) -&gt; dict[str, Any]\n</code></pre> <p>Migrates a STAC dictionary to another version.</p> <p>Migration can be as simple as updating the <code>stac_version</code> attribute, but sometimes can be more complicated. For example, when migrating to v1.1.0, eo:bands and raster:bands should be consolidated to the new bands structure.</p> <p>See the stac-rs documentation for supported versions.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The STAC value to migrate</p> </li> <li> <code>version</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The version to migrate to. If not provided, the value will be migrated to the latest stable version.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>The migrated dictionary</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with open(\"examples/simple-item.json\") as f:\n&gt;&gt;&gt;     item = json.load(f)\n&gt;&gt;&gt; item = stacrs.migrate(item, \"1.1.0-beta.1\")\n&gt;&gt;&gt; assert item[\"stac_version\"] == \"1.1.0-beta.1\"\n</code></pre>"},{"location":"api/migrate/#stacrs.migrate_href","title":"stacrs.migrate_href","text":"<pre><code>migrate_href(href: str, version: Optional[str] = None) -&gt; dict[str, Any]\n</code></pre> <p>Migrates a STAC dictionary at the given href to another version.</p> <p>Migration can be as simple as updating the <code>stac_version</code> attribute, but sometimes can be more complicated. For example, when migrating to v1.1.0, eo:bands and raster:bands should be consolidated to the new bands structure.</p> <p>See the stac-rs documentation for supported versions.</p> <p>Parameters:</p> <ul> <li> <code>href</code>               (<code>str</code>)           \u2013            <p>The href to read the STAC object from</p> </li> <li> <code>version</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The version to migrate to. If not provided, the value will be migrated to the latest stable version.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; item = stacrs.migrate_href(\"examples/simple-item.json\", \"1.1.0-beta.1\")\n&gt;&gt;&gt; assert item[\"stac_version\"] == \"1.1.0-beta.1\"\n</code></pre>"},{"location":"api/read/","title":"Read","text":""},{"location":"api/read/#stacrs.read","title":"stacrs.read  <code>async</code>","text":"<pre><code>read(\n    href: str,\n    *,\n    format: str | None = None,\n    options: list[tuple[str, str]] | None = None,\n    set_self_link: bool = True,\n) -&gt; dict[str, Any]\n</code></pre> <p>Reads STAC from a href.</p> <p>Parameters:</p> <ul> <li> <code>href</code>               (<code>str</code>)           \u2013            <p>The href to write to</p> </li> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The input format. If not provided, will be inferred from the href's extension.</p> </li> <li> <code>options</code>               (<code>list[tuple[str, str]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Options for configuring an object store, e.g. your AWS credentials.</p> </li> <li> <code>set_self_link</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, set the <code>self</code> link to the value of <code>href</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>The STAC value</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; item = await stacrs.read(\"item.json\")\n</code></pre>"},{"location":"api/search/","title":"Search","text":""},{"location":"api/search/#stacrs.search","title":"stacrs.search  <code>async</code>","text":"<pre><code>search(\n    href: str,\n    *,\n    intersects: Optional[str | dict[str, Any]] = None,\n    ids: Optional[str | list[str]] = None,\n    collections: Optional[str | list[str]] = None,\n    max_items: Optional[int] = None,\n    limit: Optional[int] = None,\n    bbox: Optional[list[float]] = None,\n    datetime: Optional[str] = None,\n    include: Optional[str | list[str]] = None,\n    exclude: Optional[str | list[str]] = None,\n    sortby: Optional[str | list[str]] = None,\n    filter: Optional[str | dict[str, Any]] = None,\n    query: Optional[dict[str, Any]] = None,\n    use_duckdb: Optional[bool] = None,\n    **kwargs: str,\n) -&gt; list[dict[str, Any]]\n</code></pre> <p>Searches a STAC API server.</p> <p>Parameters:</p> <ul> <li> <code>href</code>               (<code>str</code>)           \u2013            <p>The STAC API to search.</p> </li> <li> <code>intersects</code>               (<code>str | dict[str, Any] | GeoInterface | None</code>, default:                   <code>None</code> )           \u2013            <p>Searches items by performing intersection between their geometry and provided GeoJSON geometry.</p> </li> <li> <code>ids</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Array of Item ids to return.</p> </li> <li> <code>collections</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Array of one or more Collection IDs that each matching Item must be in.</p> </li> <li> <code>max_items</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The maximum number of items to iterate through.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The page size returned from the server. Use <code>max_items</code> to actually limit the number of items returned from this function.</p> </li> <li> <code>bbox</code>               (<code>list[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>Requested bounding box.</p> </li> <li> <code>datetime</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Single date+time, or a range (<code>/</code> separator), formatted to RFC 3339, section 5.6.  Use double dots .. for open date ranges.</p> </li> <li> <code>include</code>               (<code>list[str]] | None</code>, default:                   <code>None</code> )           \u2013            <p>fields to include in the response (see the extension docs) for more on the semantics).</p> </li> <li> <code>exclude</code>               (<code>list[str]] | None</code>, default:                   <code>None</code> )           \u2013            <p>fields to exclude from the response (see the extension docs) for more on the semantics).</p> </li> <li> <code>sortby</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Fields by which to sort results (use <code>-field</code> to sort descending).</p> </li> <li> <code>filter</code>               (<code>str | dict[str, Any] | none</code>, default:                   <code>None</code> )           \u2013            <p>CQL2 filter expression. Strings will be interpreted as cql2-text, dictionaries as cql2-json.</p> </li> <li> <code>query</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional filtering based on properties. It is recommended to use filter instead, if possible.</p> </li> <li> <code>use_duckdb</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Query with DuckDB. If None and the href has a 'parquet' or 'geoparquet' extension, will be set to True. Defaults to None.</p> </li> <li> <code>kwargs</code>               (<code>str</code>, default:                   <code>{}</code> )           \u2013            <p>Additional parameters to pass in to the search.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>A list of the returned STAC items.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; items = await stacrs.search(\n...     \"https://landsatlook.usgs.gov/stac-server\",\n...     collections=[\"landsat-c2l2-sr\"],\n...     intersects={\"type\": \"Point\", \"coordinates\": [-105.119, 40.173]},\n...     sortby=\"-properties.datetime\",\n...     max_items=1,\n... )\n</code></pre>"},{"location":"api/search/#stacrs.search_to","title":"stacrs.search_to  <code>async</code>","text":"<pre><code>search_to(\n    outfile: str,\n    href: str,\n    *,\n    intersects: Optional[str | dict[str, Any]] = None,\n    ids: Optional[str | list[str]] = None,\n    collections: Optional[str | list[str]] = None,\n    max_items: Optional[int] = None,\n    limit: Optional[int] = None,\n    bbox: Optional[list[float]] = None,\n    datetime: Optional[str] = None,\n    include: Optional[str | list[str]] = None,\n    exclude: Optional[str | list[str]] = None,\n    sortby: Optional[str | list[str]] = None,\n    filter: Optional[str | dict[str, Any]] = None,\n    query: Optional[dict[str, Any]] = None,\n    format: Optional[str] = None,\n    options: Optional[list[Tuple[str, str]]] = None,\n    use_duckdb: Optional[bool] = None,\n) -&gt; int\n</code></pre> <p>Searches a STAC API server and saves the result to an output file.</p> <p>Parameters:</p> <ul> <li> <code>outfile</code>               (<code>str</code>)           \u2013            <p>The output href. This can be a local file path, or any url scheme supported by [stac::object_store::write].</p> </li> <li> <code>href</code>               (<code>str</code>)           \u2013            <p>The STAC API to search.</p> </li> <li> <code>intersects</code>               (<code>str | dict[str, Any] | GeoInterface | None</code>, default:                   <code>None</code> )           \u2013            <p>Searches items by performing intersection between their geometry and provided GeoJSON geometry.</p> </li> <li> <code>ids</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Array of Item ids to return.</p> </li> <li> <code>collections</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Array of one or more Collection IDs that each matching Item must be in.</p> </li> <li> <code>max_items</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The maximum number of items to iterate through.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The page size returned from the server. Use <code>max_items</code> to actually limit the number of items returned from this function.</p> </li> <li> <code>bbox</code>               (<code>list[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>Requested bounding box.</p> </li> <li> <code>datetime</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Single date+time, or a range ('/' separator), formatted to RFC 3339, section 5.6.  Use double dots .. for open date ranges.</p> </li> <li> <code>include</code>               (<code>list[str]] | None</code>, default:                   <code>None</code> )           \u2013            <p>fields to include in the response (see the extension docs) for more on the semantics).</p> </li> <li> <code>exclude</code>               (<code>list[str]] | None</code>, default:                   <code>None</code> )           \u2013            <p>fields to exclude from the response (see the extension docs) for more on the semantics).</p> </li> <li> <code>sortby</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Fields by which to sort results (use <code>-field</code> to sort descending).</p> </li> <li> <code>filter</code>               (<code>str | dict[str, Any] | none</code>, default:                   <code>None</code> )           \u2013            <p>CQL2 filter expression. Strings will be interpreted as cql2-text, dictionaries as cql2-json.</p> </li> <li> <code>query</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional filtering based on properties. It is recommended to use filter instead, if possible.</p> </li> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The output format. If none, will be inferred from the outfile extension, and if that fails will fall back to compact JSON.</p> </li> <li> <code>options</code>               (<code>list[tuple[str, str]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Configuration values to pass to the object store backend.</p> </li> <li> <code>use_duckdb</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Query with DuckDB. If None and the href has a 'parquet' or 'geoparquet' extension, will be set to True. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The number of items written</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; count = await stacrs.search_to(\"out.parquet\",\n...     \"https://landsatlook.usgs.gov/stac-server\",\n...     collections=[\"landsat-c2l2-sr\"],\n...     intersects={\"type\": \"Point\", \"coordinates\": [-105.119, 40.173]},\n...     sortby=\"-properties.datetime\",\n...     max_items=1,\n... )\n</code></pre>"},{"location":"api/version/","title":"Version","text":""},{"location":"api/version/#stacrs.version","title":"stacrs.version","text":"<pre><code>version(name: str | None = None) -&gt; str | None\n</code></pre> <p>Returns this package's version, or the version of a upstream.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the upstream version to return. Valid values are \"stac\", \"stac-api\", \"stac-duckdb\", or \"duckdb\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>The version, or None if the name is not recognized as an upstream.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; stacrs.version()\n\"0.2.0\"\n&gt;&gt;&gt; stacrs.version(\"duckdb\")\n\"1.0.0\"\n</code></pre>"},{"location":"api/walk/","title":"Walk","text":""},{"location":"api/walk/#stacrs.walk","title":"stacrs.walk","text":"<pre><code>walk(\n    container: dict[str, Any],\n) -&gt; AsyncIterator[\n    tuple[dict[str, Any], list[dict[str, Any]], list[dict[str, Any]]]\n]\n</code></pre> <p>Recursively walks a STAC catalog or collection breadth-first.</p> <p>Parameters:</p> <ul> <li> <code>container</code>               (<code>dict[str, Any]</code>)           \u2013            <p>A STAC catalog or collection.</p> </li> </ul> <p>Yields:</p> <ul> <li> <code>AsyncIterator[tuple[dict[str, Any], list[dict[str, Any]], list[dict[str, Any]]]]</code>           \u2013            <p>A three-tuple of the container, its children, and its items.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; async for container, children, items in stacrs.walk(catalog):\n...     ...\n</code></pre>"},{"location":"api/write/","title":"Write","text":""},{"location":"api/write/#stacrs.write","title":"stacrs.write  <code>async</code>","text":"<pre><code>write(\n    href: str,\n    value: dict[str, Any] | list[dict[str, Any]],\n    *,\n    format: str | None = None,\n    options: list[tuple[str, str]] | None = None,\n) -&gt; dict[str, str] | None\n</code></pre> <p>Writes STAC to a href.</p> <p>Parameters:</p> <ul> <li> <code>href</code>               (<code>str</code>)           \u2013            <p>The href to write to</p> </li> <li> <code>value</code>               (<code>dict[str, Any] | list[dict[str, Any]]</code>)           \u2013            <p>The value to write. This can be a STAC dictionary or a list of items.</p> </li> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The output format to write. If not provided, will be inferred from the href's extension.</p> </li> <li> <code>options</code>               (<code>list[tuple[str, str]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Options for configuring an object store, e.g. your AWS credentials.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, str] | None</code>           \u2013            <p>The result of putting data into an object store, e.g. the e_tag and the version. None is returned if the file was written locally.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with open(\"items.json\") as f:\n...     items = json.load(f)\n&gt;&gt;&gt; await stacrs.write(\"items.parquet\", items)\n</code></pre>"}]}