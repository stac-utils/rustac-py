{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"stacrs","text":"<p>A small no-dependency Python package for STAC, using Rust under the hood.</p>"},{"location":"#why","title":"Why?","text":"<p>Why make a new STAC Python library, when we already have PySTAC? Well, we've built some things in stac-rs (a collection of STAC Rust libraries) that we want to provide to the Python ecosystem, such as:</p> <ul> <li>Read, write, and search stac-geoparquet</li> <li><code>async</code> functions</li> </ul> <p>If you don't need those things, stacrs probably isn't for you \u2014 use pystac and its friend, pystac-client, instead.</p>"},{"location":"#usage","title":"Usage","text":"<p>Install via pip:</p> <pre><code>python -m pip install stacrs\n</code></pre> <p>Or via conda:</p> <pre><code>conda install conda-forge::stacrs\n</code></pre> <p>Then:</p> <pre><code>import stacrs\n\n# Search a STAC API\nitems = await stacrs.search(\n    \"https://landsatlook.usgs.gov/stac-server\",\n    collections=\"landsat-c2l2-sr\",\n    intersects={\"type\": \"Point\", \"coordinates\": [-105.119, 40.173]},\n    sortby=\"-properties.datetime\",\n    max_items=100,\n)\n\n# Write items to a stac-geoparquet file\nawait stacrs.write(\"items.parquet\", items)\n\n# Read items from a stac-geoparquet file as an item collection\nitem_collection = await stacrs.read(\"items.parquet\")\n\n# You can search geoparquet files using DuckDB\n# If you want to search a file on s3, make sure to configure your AWS environment first\nitem_collection = await stacrs.search(\"s3://bucket/items.parquet\", ...)\n\n# Use `search_to` for better performance if you know you'll be writing the items\n# to a file\nawait stacrs.search_to(\n    \"items.parquet\",\n    \"https://landsatlook.usgs.gov/stac-server\",\n    collections=\"landsat-c2l2-sr\",\n    intersects={\"type\": \"Point\", \"coordinates\": [-105.119, 40.173]},\n    sortby=\"-properties.datetime\",\n    max_items=100,\n)\n</code></pre> <p>See the documentation for details. In particular, our example notebook demonstrates some of the more interesting features.</p>"},{"location":"#cli","title":"CLI","text":"<p>We have a pip-installable command-line interface (CLI) that exposes much of the same functionality:</p> <pre><code>$ python -m pip install stacrs-cli\n$ stacrs -h\nstacrs: A command-line interface for the SpatioTemporal Asset Catalog (STAC)\n\nUsage: stacrs [OPTIONS] &lt;COMMAND&gt;\n\nCommands:\n  translate  Translates STAC from one format to another\n  search     Searches a STAC API or stac-geoparquet file\n  serve      Serves a STAC API\n  validate   Validates a STAC value\n  help       Print this message or the help of the given subcommand(s)\n\nOptions:\n  -i, --input-format &lt;INPUT_FORMAT&gt;\n          The input format.\n      --opt &lt;OPTIONS&gt;\n          Options for getting and putting files from object storage.\n  -o, --output-format &lt;OUTPUT_FORMAT&gt;\n          The output format.\n  -c, --compact-json &lt;COMPACT_JSON&gt;\n          Whether to print compact JSON output [possible values: true, false]\n      --parquet-compression &lt;PARQUET_COMPRESSION&gt;\n          The parquet compression to use when writing stac-geoparquet.\n  -h, --help\n          Print help (see more with '--help')\n</code></pre> <p>The code for the CLI lives in the stac-rs repo, so please open any issues or feature requests over there, if possible.</p>"},{"location":"#comparisons","title":"Comparisons","text":"<p>This package (intentionally) has limited functionality, as it is not intended to be a replacement for existing Python STAC packages. pystac is a mature Python library with a significantly richer API for working with STAC objects. For querying STAC APIs, pystac-client is more feature-rich than our simplistic <code>stacrs.search</code>.</p> <p>That being said, it is hoped that stacrs will be a nice complement to the existing Python STAC ecosystem by providing a no-dependency package with unique capabilities, such as searching directly into a stac-geoparquet file.</p>"},{"location":"#stac-geoparquet","title":"stac-geoparquet","text":"<p>stacrs also replicates much of the behavior in the stac-geoparquet library, and even uses some of the same Rust dependencies. We believe there are a couple of issues with stac-geoparquet that make stacrs a worthy replacement:</p> <ul> <li>The stac-geoparquet repo includes Python dependencies</li> <li>It doesn't have a nice one-shot API for reading and writing</li> <li>It includes some leftover code and logic from its genesis as a tool for the Microsoft Planetary Computer</li> </ul> <p>We test to ensure compatibility between the two libraries, and we intend to consolidate to a single \"stac-geoparquet\" library at some point in the future.</p>"},{"location":"#development","title":"Development","text":"<p>Get Rust and uv. Then:</p> <pre><code>git clone git@github.com:stac-utils/stacrs.git\ncd stacrs\nscripts/test  # This will take a little while while the Rust dependencies build, especially DuckDB\n</code></pre> <p>See CONTRIBUTING.md for more information about contributing to this project.</p>"},{"location":"#license","title":"License","text":"<p>stacrs is dual-licensed under both the MIT license and the Apache license (Version 2.0). See LICENSE-APACHE and LICENSE-MIT for details.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to stacrs","text":"<p>First off, thanks for contributing! We appreciates you.</p>"},{"location":"CONTRIBUTING/#testing","title":"Testing","text":"<p>We aim for comprehensive unit testing of this library. Please provide tests for any new features, or to demonstrate bugs. Draft pull requests with a failing test to demonstrate a bug are much appreciated.</p>"},{"location":"CONTRIBUTING/#submitting-changes","title":"Submitting changes","text":"<p>Please open a pull request with your changes -- make sure to include unit tests. Please follow standard git commit formatting (subject line 50 characters max, wrap the body at 72 characters).</p> <p>We use conventional commits. Your commits do not have to but if you'd like to format them this way, we would be grateful.</p> <p>If you can, use <code>git rebase -i</code> to create a clean, well-formatted history before opening your pull request. If you need to make changes after opening your pull request (e.g. to fix CI breakages) we will be grateful if you squash those fixes into their relevant commits.</p> <p>Thanks so much!</p> <p>-Pete Gadomski</p>"},{"location":"example/","title":"Example notebook","text":"In\u00a0[2]: Copied! <pre>import os.path\n\nimport stacrs\nimport humanize\n\nitems = stacrs.search(\n    \"https://landsatlook.usgs.gov/stac-server\",\n    collections=\"landsat-c2l2-sr\",\n    intersects={\"type\": \"Point\", \"coordinates\": [-105.119, 40.173]},\n    sortby=\"-properties.datetime\",\n    max_items=1000,\n)\nstacrs.write(\"items.json\", items)  # GeoJSON feature collection\nstacrs.write(\"items.ndjson\", items)  # newline-delimited JSON\nstacrs.write(\"items.parquet\", items)  # stac-geoparquet\nstacrs.write(  # compressed stac-geoparquet\n    \"items-compressed.parquet\", items, format=\"parquet[snappy]\"\n)\n\nfor file_name in (\n    \"items.json\",\n    \"items.ndjson\",\n    \"items.parquet\",\n    \"items-compressed.parquet\",\n):\n    print(f\"{file_name}: {humanize.naturalsize(os.path.getsize(file_name))}\")\n\nitems = stacrs.read(\"items-compressed.parquet\")\nassert len(items[\"features\"]) == 1000\n</pre> import os.path  import stacrs import humanize  items = stacrs.search(     \"https://landsatlook.usgs.gov/stac-server\",     collections=\"landsat-c2l2-sr\",     intersects={\"type\": \"Point\", \"coordinates\": [-105.119, 40.173]},     sortby=\"-properties.datetime\",     max_items=1000, ) stacrs.write(\"items.json\", items)  # GeoJSON feature collection stacrs.write(\"items.ndjson\", items)  # newline-delimited JSON stacrs.write(\"items.parquet\", items)  # stac-geoparquet stacrs.write(  # compressed stac-geoparquet     \"items-compressed.parquet\", items, format=\"parquet[snappy]\" )  for file_name in (     \"items.json\",     \"items.ndjson\",     \"items.parquet\",     \"items-compressed.parquet\", ):     print(f\"{file_name}: {humanize.naturalsize(os.path.getsize(file_name))}\")  items = stacrs.read(\"items-compressed.parquet\") assert len(items[\"features\"]) == 1000 <pre>items.json: 21.4 MB\nitems.ndjson: 21.4 MB\nitems.parquet: 488.2 kB\nitems-compressed.parquet: 178.8 kB\n</pre> In\u00a0[3]: Copied! <pre>import contextily\nimport stacrs\nfrom geopandas import GeoDataFrame\n\nurl = \"https://github.com/gadomski/2024-09-FOSS4G-NA-stac-rs/raw/refs/heads/main/benches/1000-sentinel-2-items-stac-rs.parquet\"\nitems = stacrs.search(\n    url, intersects={\"type\": \"Point\", \"coordinates\": [-105.1019, 40.1672]}\n)\ndata_frame = GeoDataFrame.from_features(items, crs=\"EPSG:4326\")\naxis = data_frame.plot(facecolor=\"none\")\ncontextily.add_basemap(axis, crs=data_frame.crs.to_string())\n</pre> import contextily import stacrs from geopandas import GeoDataFrame  url = \"https://github.com/gadomski/2024-09-FOSS4G-NA-stac-rs/raw/refs/heads/main/benches/1000-sentinel-2-items-stac-rs.parquet\" items = stacrs.search(     url, intersects={\"type\": \"Point\", \"coordinates\": [-105.1019, 40.1672]} ) data_frame = GeoDataFrame.from_features(items, crs=\"EPSG:4326\") axis = data_frame.plot(facecolor=\"none\") contextily.add_basemap(axis, crs=data_frame.crs.to_string()) In\u00a0[4]: Copied! <pre>stacrs.search_to(\n    \"items-compressed.parquet\",\n    \"https://landsatlook.usgs.gov/stac-server\",\n    collections=\"landsat-c2l2-sr\",\n    intersects={\"type\": \"Point\", \"coordinates\": [-105.119, 40.173]},\n    sortby=\"-properties.datetime\",\n    max_items=1000,\n    format=\"parquet[snappy]\",\n)\n</pre> stacrs.search_to(     \"items-compressed.parquet\",     \"https://landsatlook.usgs.gov/stac-server\",     collections=\"landsat-c2l2-sr\",     intersects={\"type\": \"Point\", \"coordinates\": [-105.119, 40.173]},     sortby=\"-properties.datetime\",     max_items=1000,     format=\"parquet[snappy]\", ) Out[4]: <pre>1000</pre> In\u00a0[3]: Copied! <pre>import time\nfrom pystac_client import Client\nimport stacrs\n\nclient = Client.open(\"https://stac.eoapi.dev\")\nstart = time.time()\nitem_search = client.search(collections=[\"WildFires-LosAngeles-Jan-2025\"])\nitems = list(item_search.items_as_dicts())\nend = time.time()\nprint(f\"pystac-client: {end - start}s ({len(items)} items)\")\n\nstart = time.time()\nitems = await stacrs.search(\n    \"https://stac.eoapi.dev\", collections=[\"WildFires-LosAngeles-Jan-2025\"]\n)\nend = time.time()\nprint(f\"stacrs: {end - start}s ({len(items)} items)\")\n</pre> import time from pystac_client import Client import stacrs  client = Client.open(\"https://stac.eoapi.dev\") start = time.time() item_search = client.search(collections=[\"WildFires-LosAngeles-Jan-2025\"]) items = list(item_search.items_as_dicts()) end = time.time() print(f\"pystac-client: {end - start}s ({len(items)} items)\")  start = time.time() items = await stacrs.search(     \"https://stac.eoapi.dev\", collections=[\"WildFires-LosAngeles-Jan-2025\"] ) end = time.time() print(f\"stacrs: {end - start}s ({len(items)} items)\") <pre>pystac-client: 7.5231709480285645s (467 items)\nstacrs: 7.2893760204315186s (467 items)\n</pre>"},{"location":"example/#example-notebook","title":"Example notebook\u00b6","text":"<p>This notebook demonstrates some of the more interesting features of stacrs.</p>"},{"location":"example/#stac-geoparquet","title":"stac-geoparquet\u00b6","text":"<p>stac-geoparquet is a relatively new specification that describes how to store STAC items in a geoparquet. Use stacrs to read and write stac-geoparquet.</p>"},{"location":"example/#search","title":"Search\u00b6","text":"<p>As seen above, you can <code>search</code> STAC APIs. Using DuckDB, you can search stac-geoparquet files as well, both local and remote.</p>"},{"location":"example/#search-to","title":"Search to\u00b6","text":"<p>If you want to save the results of a STAC API search directly to a file, use <code>search_to</code>. This will generally be more performant than using <code>search</code> then <code>write</code>.</p>"},{"location":"example/#search-performance","title":"Search performance\u00b6","text":"<p>Here's a performance comparison when searching with stacrs versus pystac-client.</p>"},{"location":"api/","title":"Python API","text":"<p>API documentation for the stacrs Python package.</p>"},{"location":"api/duckdb/","title":"DuckDB","text":""},{"location":"api/duckdb/#stacrs.DuckdbClient","title":"stacrs.DuckdbClient","text":"<p>A client for querying stac-geoparquet with DuckDB.</p>"},{"location":"api/duckdb/#stacrs.DuckdbClient.__init__","title":"__init__","text":"<pre><code>__init__(use_s3_credential_chain: bool = True, use_hive_partitioning: bool = False) -&gt; None\n</code></pre> <p>Creates a new duckdb client.</p> <p>Parameters:</p> <ul> <li> <code>use_s3_credential_chain</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If true, configures DuckDB to correctly handle s3:// urls.</p> </li> <li> <code>use_hive_partitioning</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, enables queries on hive partitioned geoparquet files.</p> </li> </ul>"},{"location":"api/duckdb/#stacrs.DuckdbClient.get_collections","title":"get_collections","text":"<pre><code>get_collections(href: str) -&gt; list[dict[str, Any]]\n</code></pre> <p>Returns all collections in this stac-geoparquet file.</p> <p>These collections will be auto-generated from the STAC items, one collection per id in the <code>collections</code> column.</p> <p>Eventually, these collections might be stored in the stac-geoparquet metadata and retrieved from there, but that's not the case yet.</p> <p>Parameters:</p> <ul> <li> <code>href</code>               (<code>str</code>)           \u2013            <p>The stac-geoparquet file to build the collections from.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>A list of STAC Collections</p> </li> </ul>"},{"location":"api/duckdb/#stacrs.DuckdbClient.search","title":"search","text":"<pre><code>search(href: str, *, ids: Optional[str | list[str]] = None, collections: Optional[str | list[str]] = None, intersects: Optional[str | dict[str, Any]] = None, limit: Optional[int] = None, offset: Optional[int] = None, bbox: Optional[list[float]] = None, datetime: Optional[str] = None, include: Optional[str | list[str]] = None, exclude: Optional[str | list[str]] = None, sortby: Optional[str | list[str]] = None, filter: Optional[str | dict[str, Any]] = None, query: Optional[dict[str, Any]] = None, **kwargs: str) -&gt; dict[str, Any]\n</code></pre> <p>Search a stac-geoparquet file with duckdb, returning an item collection.</p> <p>Parameters:</p> <ul> <li> <code>href</code>               (<code>str</code>)           \u2013            <p>The stac-geoparquet file.</p> </li> <li> <code>ids</code>               (<code>Optional[str | list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Array of Item ids to return.</p> </li> <li> <code>collections</code>               (<code>Optional[str | list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Array of one or more Collection IDs that each matching Item must be in.</p> </li> <li> <code>intersects</code>               (<code>Optional[str | dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>Searches items by performing intersection between their geometry and provided GeoJSON geometry.</p> </li> <li> <code>limit</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>The number of items to return.</p> </li> <li> <code>offset</code>               (<code>Optional[int]</code>, default:                   <code>None</code> )           \u2013            <p>The number of items to skip before returning.</p> </li> <li> <code>bbox</code>               (<code>Optional[list[float]]</code>, default:                   <code>None</code> )           \u2013            <p>Requested bounding box.</p> </li> <li> <code>datetime</code>               (<code>Optional[str]</code>, default:                   <code>None</code> )           \u2013            <p>Single date+time, or a range (<code>/</code> separator), formatted to RFC 3339, section 5.6.  Use double dots .. for open date ranges.</p> </li> <li> <code>include</code>               (<code>Optional[str | list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>fields to include in the response (see the extension docs) for more on the semantics).</p> </li> <li> <code>exclude</code>               (<code>Optional[str | list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>fields to exclude from the response (see the extension docs) for more on the semantics).</p> </li> <li> <code>sortby</code>               (<code>Optional[str | list[str]]</code>, default:                   <code>None</code> )           \u2013            <p>Fields by which to sort results (use <code>-field</code> to sort descending).</p> </li> <li> <code>filter</code>               (<code>Optional[str | dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>CQL2 filter expression. Strings will be interpreted as cql2-text, dictionaries as cql2-json.</p> </li> <li> <code>query</code>               (<code>Optional[dict[str, Any]]</code>, default:                   <code>None</code> )           \u2013            <p>Additional filtering based on properties.  It is recommended to use filter instead, if possible.</p> </li> <li> <code>kwargs</code>               (<code>str</code>, default:                   <code>{}</code> )           \u2013            <p>Additional parameters to pass in to the search.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>dict[str, Any]: A feature collection of STAC items.</p> </li> </ul>"},{"location":"api/migrate/","title":"Migration","text":""},{"location":"api/migrate/#stacrs.migrate","title":"stacrs.migrate","text":"<pre><code>migrate(value: dict[str, Any], version: Optional[str] = None) -&gt; dict[str, Any]\n</code></pre> <p>Migrates a STAC dictionary to another version.</p> <p>Migration can be as simple as updating the <code>stac_version</code> attribute, but sometimes can be more complicated. For example, when migrating to v1.1.0, eo:bands and raster:bands should be consolidated to the new bands structure.</p> <p>See the stac-rs documentation for supported versions.</p> <p>Parameters:</p> <ul> <li> <code>value</code>               (<code>dict[str, Any]</code>)           \u2013            <p>The STAC value to migrate</p> </li> <li> <code>version</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The version to migrate to. If not provided, the value will be migrated to the latest stable version.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>dict[str, Any]: The migrated dictionary</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with open(\"examples/simple-item.json\") as f:\n&gt;&gt;&gt;     item = json.load(f)\n&gt;&gt;&gt; item = stacrs.migrate(item, \"1.1.0-beta.1\")\n&gt;&gt;&gt; assert item[\"stac_version\"] == \"1.1.0-beta.1\"\n</code></pre>"},{"location":"api/migrate/#stacrs.migrate_href","title":"stacrs.migrate_href","text":"<pre><code>migrate_href(href: str, version: Optional[str] = None) -&gt; dict[str, Any]\n</code></pre> <p>Migrates a STAC dictionary at the given href to another version.</p> <p>Migration can be as simple as updating the <code>stac_version</code> attribute, but sometimes can be more complicated. For example, when migrating to v1.1.0, eo:bands and raster:bands should be consolidated to the new bands structure.</p> <p>See the stac-rs documentation for supported versions.</p> <p>Parameters:</p> <ul> <li> <code>href</code>               (<code>str</code>)           \u2013            <p>The href to read the STAC object from</p> </li> <li> <code>version</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The version to migrate to. If not provided, the value will be migrated to the latest stable version.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; item = stacrs.migrate_href(\"examples/simple-item.json\", \"1.1.0-beta.1\")\n&gt;&gt;&gt; assert item[\"stac_version\"] == \"1.1.0-beta.1\"\n</code></pre>"},{"location":"api/read/","title":"Read","text":""},{"location":"api/read/#stacrs.read","title":"stacrs.read  <code>async</code>","text":"<pre><code>read(href: str, *, format: str | None = None, options: list[tuple[str, str]] | None = None) -&gt; dict[str, Any]\n</code></pre> <p>Reads STAC from a href.</p> <p>Parameters:</p> <ul> <li> <code>href</code>               (<code>str</code>)           \u2013            <p>The href to write to</p> </li> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The input format. If not provided, will be inferred from the href's extension.</p> </li> <li> <code>options</code>               (<code>list[tuple[str, str]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Options for configuring an object store, e.g. your AWS credentials.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, Any]</code>           \u2013            <p>dict[str, Any]: The STAC value</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; item = await stacrs.read(\"item.json\")\n</code></pre>"},{"location":"api/search/","title":"Search","text":""},{"location":"api/search/#stacrs.search","title":"stacrs.search  <code>async</code>","text":"<pre><code>search(href: str, *, intersects: Optional[str | dict[str, Any]] = None, ids: Optional[str | list[str]] = None, collections: Optional[str | list[str]] = None, max_items: Optional[int] = None, limit: Optional[int] = None, bbox: Optional[list[float]] = None, datetime: Optional[str] = None, include: Optional[str | list[str]] = None, exclude: Optional[str | list[str]] = None, sortby: Optional[str | list[str]] = None, filter: Optional[str | dict[str, Any]] = None, query: Optional[dict[str, Any]] = None, use_duckdb: Optional[bool] = None, **kwargs: str) -&gt; list[dict[str, Any]]\n</code></pre> <p>Searches a STAC API server.</p> <p>Parameters:</p> <ul> <li> <code>href</code>               (<code>str</code>)           \u2013            <p>The STAC API to search.</p> </li> <li> <code>intersects</code>               (<code>str | dict[str, Any] | GeoInterface | None</code>, default:                   <code>None</code> )           \u2013            <p>Searches items by performing intersection between their geometry and provided GeoJSON geometry.</p> </li> <li> <code>ids</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Array of Item ids to return.</p> </li> <li> <code>collections</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Array of one or more Collection IDs that each matching Item must be in.</p> </li> <li> <code>max_items</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The maximum number of items to iterate through.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The page size returned from the server. Use <code>max_items</code> to actually limit the number of items returned from this function.</p> </li> <li> <code>bbox</code>               (<code>list[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>Requested bounding box.</p> </li> <li> <code>datetime</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Single date+time, or a range (<code>/</code> separator), formatted to RFC 3339, section 5.6.  Use double dots .. for open date ranges.</p> </li> <li> <code>include</code>               (<code>list[str]] | None</code>, default:                   <code>None</code> )           \u2013            <p>fields to include in the response (see the extension docs) for more on the semantics).</p> </li> <li> <code>exclude</code>               (<code>list[str]] | None</code>, default:                   <code>None</code> )           \u2013            <p>fields to exclude from the response (see the extension docs) for more on the semantics).</p> </li> <li> <code>sortby</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Fields by which to sort results (use <code>-field</code> to sort descending).</p> </li> <li> <code>filter</code>               (<code>str | dict[str, Any] | none</code>, default:                   <code>None</code> )           \u2013            <p>CQL2 filter expression. Strings will be interpreted as cql2-text, dictionaries as cql2-json.</p> </li> <li> <code>query</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional filtering based on properties. It is recommended to use filter instead, if possible.</p> </li> <li> <code>use_duckdb</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Query with DuckDB. If None and the href has a 'parquet' or 'geoparquet' extension, will be set to True. Defaults to None.</p> </li> <li> <code>kwargs</code>               (<code>str</code>, default:                   <code>{}</code> )           \u2013            <p>Additional parameters to pass in to the search.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict[str, Any]]</code>           \u2013            <p>list[dict[str, Any]]: A list of the returned STAC items.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; items = await stacrs.search(\n...     \"https://landsatlook.usgs.gov/stac-server\",\n...     collections=[\"landsat-c2l2-sr\"],\n...     intersects={\"type\": \"Point\", \"coordinates\": [-105.119, 40.173]},\n...     sortby=\"-properties.datetime\",\n...     max_items=1,\n... )\n</code></pre>"},{"location":"api/search/#stacrs.search_to","title":"stacrs.search_to  <code>async</code>","text":"<pre><code>search_to(outfile: str, href: str, *, intersects: Optional[str | dict[str, Any]] = None, ids: Optional[str | list[str]] = None, collections: Optional[str | list[str]] = None, max_items: Optional[int] = None, limit: Optional[int] = None, bbox: Optional[list[float]] = None, datetime: Optional[str] = None, include: Optional[str | list[str]] = None, exclude: Optional[str | list[str]] = None, sortby: Optional[str | list[str]] = None, filter: Optional[str | dict[str, Any]] = None, query: Optional[dict[str, Any]] = None, format: Optional[str] = None, options: Optional[list[Tuple[str, str]]] = None, use_duckdb: Optional[bool] = None) -&gt; int\n</code></pre> <p>Searches a STAC API server and saves the result to an output file.</p> <p>Parameters:</p> <ul> <li> <code>outfile</code>               (<code>str</code>)           \u2013            <p>The output href. This can be a local file path, or any url scheme supported by [stac::object_store::write].</p> </li> <li> <code>href</code>               (<code>str</code>)           \u2013            <p>The STAC API to search.</p> </li> <li> <code>intersects</code>               (<code>str | dict[str, Any] | GeoInterface | None</code>, default:                   <code>None</code> )           \u2013            <p>Searches items by performing intersection between their geometry and provided GeoJSON geometry.</p> </li> <li> <code>ids</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Array of Item ids to return.</p> </li> <li> <code>collections</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Array of one or more Collection IDs that each matching Item must be in.</p> </li> <li> <code>max_items</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The maximum number of items to iterate through.</p> </li> <li> <code>limit</code>               (<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The page size returned from the server. Use <code>max_items</code> to actually limit the number of items returned from this function.</p> </li> <li> <code>bbox</code>               (<code>list[float] | None</code>, default:                   <code>None</code> )           \u2013            <p>Requested bounding box.</p> </li> <li> <code>datetime</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Single date+time, or a range ('/' separator), formatted to RFC 3339, section 5.6.  Use double dots .. for open date ranges.</p> </li> <li> <code>include</code>               (<code>list[str]] | None</code>, default:                   <code>None</code> )           \u2013            <p>fields to include in the response (see the extension docs) for more on the semantics).</p> </li> <li> <code>exclude</code>               (<code>list[str]] | None</code>, default:                   <code>None</code> )           \u2013            <p>fields to exclude from the response (see the extension docs) for more on the semantics).</p> </li> <li> <code>sortby</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Fields by which to sort results (use <code>-field</code> to sort descending).</p> </li> <li> <code>filter</code>               (<code>str | dict[str, Any] | none</code>, default:                   <code>None</code> )           \u2013            <p>CQL2 filter expression. Strings will be interpreted as cql2-text, dictionaries as cql2-json.</p> </li> <li> <code>query</code>               (<code>dict[str, Any] | None</code>, default:                   <code>None</code> )           \u2013            <p>Additional filtering based on properties. It is recommended to use filter instead, if possible.</p> </li> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The output format. If none, will be inferred from the outfile extension, and if that fails will fall back to compact JSON.</p> </li> <li> <code>options</code>               (<code>list[tuple[str, str]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Configuration values to pass to the object store backend.</p> </li> <li> <code>use_duckdb</code>               (<code>bool | None</code>, default:                   <code>None</code> )           \u2013            <p>Query with DuckDB. If None and the href has a 'parquet' or 'geoparquet' extension, will be set to True. Defaults to None.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>The number of items written</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; count = await stacrs.search_to(\"out.parquet\",\n...     \"https://landsatlook.usgs.gov/stac-server\",\n...     collections=[\"landsat-c2l2-sr\"],\n...     intersects={\"type\": \"Point\", \"coordinates\": [-105.119, 40.173]},\n...     sortby=\"-properties.datetime\",\n...     max_items=1,\n... )\n</code></pre>"},{"location":"api/version/","title":"Version","text":""},{"location":"api/version/#stacrs.version","title":"stacrs.version","text":"<pre><code>version(name: str | None = None) -&gt; str | None\n</code></pre> <p>Returns this package's version, or the version of a upstream.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The name of the upstream version to return. Valid values are \"stac\", \"stac-api\", \"stac-duckdb\", or \"duckdb\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code> (              <code>str | None</code> )          \u2013            <p>The version, or None if the name is not recognized as an upstream.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; stacrs.version()\n\"0.2.0\"\n&gt;&gt;&gt; stacrs.version(\"duckdb\")\n\"1.0.0\"\n</code></pre>"},{"location":"api/write/","title":"Write","text":""},{"location":"api/write/#stacrs.write","title":"stacrs.write  <code>async</code>","text":"<pre><code>write(href: str, value: dict[str, Any] | list[dict[str, Any]], *, format: str | None = None, options: list[tuple[str, str]] | None = None) -&gt; dict[str, str] | None\n</code></pre> <p>Writes STAC to a href.</p> <p>Parameters:</p> <ul> <li> <code>href</code>               (<code>str</code>)           \u2013            <p>The href to write to</p> </li> <li> <code>value</code>               (<code>dict[str, Any] | list[dict[str, Any]]</code>)           \u2013            <p>The value to write. This can be a STAC dictionary or a list of items.</p> </li> <li> <code>format</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The output format to write. If not provided, will be inferred from the href's extension.</p> </li> <li> <code>options</code>               (<code>list[tuple[str, str]] | None</code>, default:                   <code>None</code> )           \u2013            <p>Options for configuring an object store, e.g. your AWS credentials.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict[str, str] | None</code>           \u2013            <p>dict[str, str] | None: The result of putting data into an object store, e.g. the e_tag and the version. None is returned if the file was written locally.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; with open(\"items.json\") as f:\n...     items = json.load(f)\n&gt;&gt;&gt; await stacrs.write(\"items.parquet\", items)\n</code></pre>"}]}